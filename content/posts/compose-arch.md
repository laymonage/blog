+++
title = "Microservices architecture... composed"
date = 2020-04-30T07:43:03+07:00
tags = ["ppl", "docker"]
toc = false
comments = true
draft = false
description = """
Managing multiple services in a microservices architecture can be quite painful.
Thankfully, there's a tool that can help us.
"""
images = ["/images/uploads/ppl-architecture-composed.png"]
+++

As [previously described][clean-tools], my group and I are building a web
service that's connected to two other services: our partner's service and
our database service. The following is an illustration of the architecture.

{{< figure src="/images/uploads/ppl-architecture.png"
caption="Our microservices architecture." >}}

There are three main services that we're working on:

- **Frontend**: a progressive web app (PWA) built with Vue and Quasar.
- **Gateway**: the backend, so to speak. It's connected to our partner's API,
  since we're building an extension to their current system.
- **DB Service**: a simple service that's connected to a MySQL database server.
  It acts as an interface between the gateway and the database server. This
  isn't actually necessary, but our partner asked us to do it this way to make
  integrations easier later on.

Ideally, each service would be deployed to its own node. However, since we
cannot afford that, we decided to put the whole thing on one server. Well,
at least for the Gateway and DB Service, since we could use something like
Netlify for the Frontend.

Also, due to some restrictions applied in our course, we decided to put the
whole thing in a monolithic repository. Again, it's not ideal. However, we
had to find the balance between the ideal system and something that can be
assessed easily by the teaching team.

Anyway, configuring the services and maintaining them can be quite a task.
Each service is *containerized* with Docker and each has its own `Dockerfile`.
The monolithic repository is put on our faculty's GitLab instance. We use
GitLab CI and deploy the whole thing to a single DigitalOcean droplet. To
make things convenient, we need something that can *compose* the setup into
something more unified. Thankfully, there's a tool that can help us for
that: [**Docker Compose**][docker-compose].

To quote its description,

> **Compose** is a tool for defining and running **multi-container** Docker
> applications. With Compose, you use a **YAML** file to configure your
> applicationâ€™s services. Then, with a **single command**, you create
> and start **all** the services from your configuration.

Perfect.

So, how does it work? Well, the description says it all. After writing our
app's `Dockerfile`, we just need to create a `YAML` file to configure
our services. So, for our situation, we just need to create a
**`docker-compose.yml`** like the following:

```yaml
version: "3"

services:
  mysql:
    image: mysql:8
    environment:
      - MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD
      - MYSQL_USER=$MYSQL_USER
      - MYSQL_PASSWORD=$MYSQL_PASSWORD
      - MYSQL_DATABASE=$MYSQL_DATABASE
    env_file: ./.env
    ports:
      - "3306:3306"

  db-service:
    depends_on:
      - mysql
    build: ./db-service
    env_file: ./db-service/.env
    ports:
      - "1234:1234"

  gateway:
    depends_on:
      - db-service
    build: ./gateway
    env_file: ./gateway/.env
    ports:
      - "4321:4321"

  frontend:
    build: ./frontend
    env_file: ./frontend/.env
    ports:
      - "8080:80"
```

I believe the above example is quite self-explanatory. You just need to
describe the name for each of your **`services`**, what `image` should it
use (whether you're `build`ing your own image or use one from the
[Docker Hub][docker-hub]), the `env_file`, and what `ports` should be exposed.

Then, a single command would bring them **up**:

```bash
$ docker-compose up
```

A single command would also bring them **down**:

```bash
$ docker-compose down
```

You can also **build** the images in a single command:

```bash
$ docker-compose build
```

That's way more **convenient** than having to run the commands for each service
and managing them one by one!

As a bonus, compose also sets up a single **network** for your app. Let's say
you put the `docker-compose.yml` file in a directory named `myapp`. Docker
Compose automatically sets up:

1. A network called `myapp_default`.
2. A container with an autogenerated name for each `service`. It joins the
   `myapp_default` network under the name defined in your configuration (i.e.
   `mysql`, `db-service`, `gateway`, and `frontend`).

So, in the `db-service`, we can just connect to the database server through
**`mysql:3306`**. In the `gateway`, we can connect to `db-service` through
**`http://db-service:1234`**. Then, we can expose `gateway` and `frontend` as
different servers with their own hostnames in an `nginx` configuration. Phew!

[clean-tools]: {{< ref "clean-tools.md" >}}
[docker-compose]: https://docs.docker.com/compose
[docker-hub]: https://hub.docker.com
